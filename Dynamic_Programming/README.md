다이나믹 프로그래밍은 문제가 다음의 조건을 만족할 때 사용할 수 있습니다.
1. 최적 부분 구조 (Optimal Substructure)
    큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있습니다
2. 중복되는 부분 문제 (Overlapping Subproblem)
    동일한 작은 문제를 반복적으로 해결해야 합니다.

피보나치 수열 다음과 같은 형태의 수열이며, 다이나믹 프로그래밍으로 효과적으로 계산할 수 있습니다.

        1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

점화식이란 인접한 항들 사이의 관계식을 의미합니다.
피보나치 수열을 점화식으로 표현하면 다음과 같습니다.

An = An-1 + An-2, A1 = 1, A2 = 1

# 피보나치 함수
def fibo(x):
    if x == 1 or x == 2:
        return 1
    return fibo(x - 1) + fibo(x - 2)
print(fibo(4))

-> 단순 재귀 함수로 피보나치 수열을 해결하면 지수 시간 복잡도를 가지게 됩니다.
여러 번 호출되는 것을 확인할 수 있음 (중복되는 부분 문제)

다이나믹 프로그래밍의 사용 조건을 만족하는지 확인합니다.
    1. 최적 부분 구조: 큰 문제를 작은 문제로 나눌 수 있다 
    ex) f(4) = f(3) + f(2)
    2. 중복되는 부분 문제: 동일한 작은 문제를 반복적으로 해결해야 합니다. ex) f(2)의 중복
    -> 피보나치 수열은 조건 만족

# 메모이제이션(Meomoization)
메모이제이션은 다이나믹 프로그래밍을 구현하는 방법 중 하나입니다.
한 번 계산한 결과를 메모리 공간에 메모하는 기법입니다.
    같은 문제를 다시 호출하면 메모했던 결과를 그대로 가져옵니다.
    값을 기록해 놓는다는 점에서 캐싱(Cashing)이라고도 합니다.

# 탑다운 VS 보텀업
탑 다운(메모이제이션) 방식은 하향식이라고도 하며 보텀업 방식은 상향식이라고도 합니다.
다이나믹 프로그래밍의 전형적인 형태는 보텀업 방식입니다.
    결과 저정용 리스트는 DP 테이블이라고 부릅니다.
엄밀히 말하면 메모이제이션은 이전에 계산된 결과를 일시적으로 기록해 놓는 넓은 개념을 의미합니다.
    따라서 메모이제이션은 다이나믹 프로그래밍에 국한된 개념은 아닙니다.
    한 번 계산된 결과를 담아 놓기만 하고 다이나믹 프로그래밍을 위해 활용하지 않을 수도 있습니다.

# 다이나믹 프로그래밍 VS 분할 정복
다이나믹 프로그래밍과 분할 정복은 모두 최적 부분 구조를 가질 때 사용할 수 있습니다.
    큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결하는 상황
다이나믹 프로그래밍과 분할 정복 차이점은 *부분 문제의 중복*입니다
    다이나믹 프로그래밍 문제에서는 각 부분 문제들이 서로 영향을 미치며 부분 문제가 중복됩니다.
    분할 정복 문제에서는 동일한 부분 문제가 반복적으로 계산되지 않습니다. Ex) 퀵 정렬 pivot은 다시 호출 X

